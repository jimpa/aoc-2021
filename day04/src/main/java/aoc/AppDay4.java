/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package aoc;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;

public class AppDay4 {
    private final Game input;

    public AppDay4(Game input) {
        this.input = input;
    }

    public static void main(String[] args) throws IOException {
        System.out.println("java");
        Game input = parseInput("input.txt");
        String part = System.getenv("part") == null ? "part1" : System.getenv("part");
        if (part.equals("part2"))
            System.out.println(new AppDay4(input).getSolutionPart2());
        else
            System.out.println(new AppDay4(input).getSolutionPart1());
    }

    private static Game parseInput(String filename) throws IOException {
        return Files.lines(Path.of(filename))
                .map(String::trim)
                .filter(line -> !line.isEmpty())
                .reduce(new GameBuilder(), GameBuilder::accumulateLine,
                        (gameBuilder, gameBuilder2) -> gameBuilder)
                .buildGame();
    }

    public int getSolutionPart1() {
        for (Integer inputNumber : input.inputSeries) {
            input.markNumber(inputNumber);
            if (input.checkForOneCompletedBoard()) {
                return input.calculatePartOneResult();
            }
        }

        throw new IllegalStateException("No single winning board was found. Can't end the game.");
    }

    public int getSolutionPart2() {
        for (Integer inputNumber : input.inputSeries) {
            if (! input.markNumber(inputNumber)) {
                break;
            }
        }

        return input.calculatePartTwoResult();
    }

    static class GameBuilder {

        private final List<Integer> inputSeries = new ArrayList<>();
        private Board currentBoard = new Board();
        private final Map<Integer, Number> allNumbers = new HashMap<>();
        private final List<Board> boards = new ArrayList<>();

        public Game buildGame() {
            Game game = new Game();
            game.allNumbers.putAll(allNumbers);
            game.inputSeries.addAll(inputSeries);
            game.boards.addAll(boards);

            return game;
        }

        public GameBuilder accumulateLine(String lineFromFile) {
            if (inputSeries.isEmpty()) {
                inputSeries.addAll(Arrays.stream(lineFromFile.split(","))
                        .map(Integer::parseInt)
                        .collect(Collectors.toList()));
                return this;
            }

            currentBoard.rows.add(new Line(lineFromFile, allNumbers, currentBoard));
            if (currentBoard.rows.size() == 5) {
                currentBoard.establishColumns();
                boards.add(currentBoard);
                currentBoard = new Board();
            }

            return this;
        }
    }

    static class Game {
        final List<Board> boards = new ArrayList<>();
        final List<Integer> inputSeries = new ArrayList<>();
        final Map<Integer, Number> allNumbers = new HashMap<>();
        LinkedHashSet<Board> completedBoards = new LinkedHashSet<>();

        public int calculatePartOneResult() {
            if (completedBoards.isEmpty()) {
                throw new IllegalStateException("No single winning board was found. Can't end the game.");
            }

            return calculateOneBoard(completedBoards.iterator().next());
        }

        public int calculatePartTwoResult() {
            if (completedBoards.isEmpty()) {
                throw new IllegalStateException("No single winning board was found. Can't end the game.");
            }

            Board[] boards = completedBoards.toArray(new Board[0]);

            return calculateOneBoard(boards[boards.length - 1]);
        }

        private int calculateOneBoard(Board board) {
            return board.getAllNumbers().stream()
                    .filter(number -> !number.found)
                    .map(n -> n.number)
                    .reduce(0, Integer::sum)
                    * board.finishingNumber
                    ;
        }

        /**
         * @return true if there was a number on an unsolved board to mark, false if everything is done.
         */
        public boolean markNumber(Integer inputNumber) {

            if (completedBoards.size() == boards.size()) {
                return false;
            }

            Optional.ofNullable(allNumbers.get(inputNumber))
                    .ifPresent(number -> {
                        number.found = true;
                        number.presentInLines.stream()
                                .filter(Line::isAllFound)
                                .forEach(line -> {
                                    line.board.completed = true;
                                    line.board.finishingNumber = inputNumber;
                                    completedBoards.add(line.board);
                                });
                    });

            return true;
        }

        public boolean checkForOneCompletedBoard() {
            return ! completedBoards.isEmpty();
        }
    }

    static class Board {
        final List<Line> rows = new ArrayList<>();
        final List<Line> columns = new ArrayList<>();
        boolean completed = false;
        Integer finishingNumber;

        public void establishColumns() {
            for (int columnPosition = 0; columnPosition < 5; columnPosition++) {
                Line column = new Line(this);
                int finalColumnPosition = columnPosition;
                rows.forEach(row -> column.numbers.add(row.numbers.get(finalColumnPosition)));
                column.numbers.forEach(number -> number.presentInLines.add(column));
                columns.add(column);
            }
        }

        public Set<Number> getAllNumbers() {
            Set<Number> result = new HashSet<>();
            result.addAll(rows.stream().flatMap(line -> line.numbers.stream()).collect(Collectors.toSet()));
            result.addAll(columns.stream().flatMap(line -> line.numbers.stream()).collect(Collectors.toSet()));
            return result;
        }
    }

    static class Line {
        final List<Number> numbers = new ArrayList<>();
        final Board board;

        public Line(Board board) {
            this.board = board;
        }

        public Line(String input, Map<Integer, Number> allNumbers, Board board) {
            this.board = board;
            Arrays.stream(input.trim().split("\\s+"))
                    .map(Integer::parseInt)
                    .map(n -> allNumbers.computeIfAbsent(n, Number::new))
                    .peek(number -> number.presentInLines.add(this))
                    .forEach(numbers::add);
        }

        public boolean isAllFound() {
            return numbers.stream()
                    .filter(number -> number.found)
                    .collect(Collectors.toSet())
                    .size() == 5;
        }
    }

    static class Number {
        final Integer number;
        boolean found;
        Set<Line> presentInLines = new HashSet<>();

        Number(int number) {
            this.number = number;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Number)) return false;
            Number number1 = (Number) o;
            return number.equals(number1.number);
        }

        @Override
        public int hashCode() {
            return Objects.hash(number);
        }
    }
}
